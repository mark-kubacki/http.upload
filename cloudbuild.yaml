# It's handy to later browse the logs trying to learn if an error is common to all runs of a language.
tags: ['golang', 'caddy', 'plugin']
# Makes it easier to repurpose this file.
substitutions:
  _PROJECT_ROOT: 'blitznote.com/src/http.upload'
# Admittedly rather cumbersome, but I've a public fork of caddy of my own (also on Github).
  _CADDY_ORIGIN: 'github.com/caddyserver/caddy'
  _CADDY_FLAVOR: 'caddyserver/caddy'

# Google's default image lacks some tools I frequently use.
# Therefore steps don't start like this:
#  name: 'gcr.io/cloud-builders/go'
#  env: ['PROJECT_ROOT=${_PROJECT_ROOT}']

# Please note, image docker.io/blitznote/golang is also *gcr.io/blitznote/golang .

steps:
# 'gofmt' only cares for the format, and doesn't touch any dependencies.
# It's a nice gatekeeper before any downloads, and to date any recent Go version will do.
- name: 'gcr.io/cloud-builders/go:debian'
  id: 'gofmt'
  entrypoint: 'bash'
  args: ['-c', 'diff <(echo -n) <(gofmt -s -d $(find . -type f -name "*.go" -not -path "./_*"))']

# Usually you'd go about this differently, for instance in hooks:
#   gofiles=$(git diff --cached --name-only --diff-filter=ACM "${origin}/master" | grep '\.go$')
#   gofmt -l $gofiles

# It's always good to cache dependencies for network connections and third-party services can be subject to interruptions and outages.
- name: 'gcr.io/cloud-builders/gsutil'
  waitFor: ['gofmt']
  volumes:
  - name: 'third-party-sources'
    path: '/var/go/theirs'
  id: 'get cache'
  entrypoint: 'bash'
  args:
  - -c
  - |
    export RELEASE="$$(curl --compressed --fail --location --silent "https://api.github.com/repos/${_CADDY_FLAVOR}/releases/latest" | grep -F tag_name | awk '{print $$2;}' | tr -d ',"')";
    if gsutil cp gs://cache_cloudbuild/caddy/dependencies-$${RELEASE}.tar.xz ./; then
      tar -C /var/go/theirs/ -xaf "dependencies-$${RELEASE}.tar.xz" && rm "dependencies-$${RELEASE}.tar.xz";
    else
      exit 0;
    fi

# Technically this is not needed, but I pay attention to timings below and like this to be excluded.
- name: 'gcr.io/cloud-builders/docker'
  waitFor: ['gofmt']
  id: 'get golang container image'
  entrypoint: 'bash'
  args:
  - -c
  - |
    if docker pull gcr.io/blitznote/golang; then
      docker tag gcr.io/blitznote/golang:latest docker.io/blitznote/golang:latest;
    else
      docker pull docker.io/blitznote/golang;
    fi

# You could skip this step, but I don't want to run checks against latest Caddyserver.
# Instead, what I will use is the latest release (including any beta) to limit the amount of code to review in case of a failed build.
- name: 'docker.io/blitznote/golang'
  waitFor: ['get cache', 'get golang container image']
  volumes:
  - name: 'third-party-sources'
    path: '/var/go/theirs'
  env: ['GOPATH=/var/go/theirs:/go:/usr/share/gocode', 'GO111MODULE=on']
  dir: '/go/src/${_PROJECT_ROOT}'
  id: 'get caddy'
  args:
  - -c
  - |
    if [ -s "/var/go/theirs/src/${_CADDY_ORIGIN}/VERSION" ]; then
      sed -i -e '/caddy\.upload/d' -e '/http\.upload/d' "/var/go/theirs/src/${_CADDY_ORIGIN}/"{go.mod,caddyhttp/httpserver/plugin.go,caddy/caddymain/run.go};
      exit 0;
    fi;
    
    mkdir -p "/var/go/theirs/src/${_CADDY_ORIGIN}";
    cd $$_;
    export RELEASE="$(curl --compressed --fail --location --silent "https://api.github.com/repos/${_CADDY_FLAVOR}/releases/latest" | jq -r '.tag_name')";
    export COMMIT="$(curl --compressed --fail --location --silent "https://api.github.com/repos/${_CADDY_FLAVOR}/tags" | jq -r ".[] | select(.name == \"$${RELEASE}\").commit.sha")";

    git init .;
    git remote add origin "https://${_CADDY_ORIGIN}.git";
    git fetch origin "$${COMMIT}";
    git reset --hard FETCH_HEAD;
    
    (cd caddy; go build . errors);
    printf "$${RELEASE}" >VERSION;
    printf "=> ${_CADDY_ORIGIN} is $${RELEASE}\n"

# Now get dependencies of this plugin.
- &use_go
  name: 'docker.io/blitznote/golang'
  volumes:
  - name: 'third-party-sources'
    path: '/var/go/theirs'
  env: ['GOPATH=/var/go/theirs:/go:/usr/share/gocode', 'GO111MODULE=on']
  dir: '/go/src/${_PROJECT_ROOT}'
  id: 'get dependencies'
  args:
  - -c
  - |
    sed -i \
      -e '/^require/a \\t${_CADDY_ORIGIN} '$$(cat /var/go/theirs/src/${_CADDY_ORIGIN}/VERSION) \
      go.mod;
    sed -i \
      -e '/caddy v/s@v[^ ]*$$@'$$(cat /var/go/theirs/src/${_CADDY_ORIGIN}/VERSION)'@' \
      go.mod;
    printf "\n\nreplace ${_CADDY_ORIGIN} => /var/go/theirs/src/${_CADDY_ORIGIN}\n" \
      >>go.mod;
    go build -tags "caddyserver0.9 caddyserver1.0" . errors;

# Now come steps (in Gitlab this were one stage actually) common to most projects written in Golang.
# Ideally run parallel.
- <<: *use_go
  id: 'vet'
  waitFor: ['get dependencies']
  args: ['go', 'vet', '-tags', 'caddyserver0.9 caddyserver1.0', './...']
- <<: *use_go
  id: 'ineffassign'
  waitFor: ['get dependencies']
  args: ['ineffassign', '.']
- <<: *use_go
  id: 'lint'
  waitFor: ['get dependencies']
  args: ['golint', './...']
- <<: *use_go
  id: 'unittests'
  waitFor: ['get dependencies']
  args: ['go', 'test', '-tags', 'caddyserver0.9 caddyserver1.0', '-v', './...']

# Build, but discard any artifacts.
- <<: *use_go
  id: 'inject plugin'
  args:
  - -c
  - |
    cd "/var/go/theirs/src/${_CADDY_ORIGIN}";
    sed -i \
      -e '/^require/a\\tblitznote.com/src/http.upload v0.0.0' \
      go.mod;
    printf "\n\nreplace blitznote.com/src/http.upload => /go/src/blitznote.com/src/http.upload\n" \
      >>go.mod;
    sed -i \
      -e '/This is where other plugins/a \\t_ "blitznote.com/src/http.upload"' \
      caddy/caddymain/run.go;
    if ! grep -qF '"upload"' caddyhttp/httpserver/plugin.go; then
      sed -i \
        -e '/"jwt"/a \\t"upload",' \
        caddyhttp/httpserver/plugin.go;
    fi

- &build_go
  <<: *use_go
  name: 'docker.io/blitznote/golang'
  waitFor: ['inject plugin']
  id: 'build linux amd64, Go current'
  env: ['GOPATH=/var/go/theirs:/go:/usr/share/gocode', 'GO111MODULE=on', 'GOARCH=amd64', 'GOOS=linux']
  args:
  - -c
  - |
    cd "/var/go/theirs/src/${_CADDY_ORIGIN}";
    export pkg="${_CADDY_ORIGIN}/caddy/caddymain";
    cd caddy;
    go build \
      -tags "caddyserver0.9 caddyserver1.0" \
      -ldflags  "-s -w -buildid '' -X '$${pkg}.gitTag=$(cat ../VERSION)'" \
      -asmflags "-trimpath=$${GOPATH}" \
      -gcflags  "-trimpath=$${GOPATH}" \
      -o caddy.upload~$${GOARCH}_$${GOOS};
    if [[ "$${GOOS}" == "linux" ]] && [[ "$${GOARCH}" == "$(dpkg --print-architecture)" ]]; then ./caddy.upload~$${GOARCH}_$${GOOS} -version; fi;
    mv caddy.upload~$${GOARCH}_$${GOOS} /workspace/

# I used to compile this with different versions of Go, but see no benefit.
#- <<: *build_go
#  name: 'docker.io/blitznote/golang:1.10'
#  id: 'build linux amd64, Go previous'
#- <<: *build_go
#  name: 'docker.io/blitznote/golang:1.12'
#  id: 'build linux amd64, Go tip'

#- <<: *build_go
#  id: 'build_windows_amd64'
#  env: ['GOPATH=/var/go/theirs:/go:/usr/share/gocode', 'GO111MODULE=on', 'GOARCH=amd64', 'GOOS=windows']

# Now come integration tests.
- name: 'gcr.io/cloud-builders/curl'
  waitFor: ['build linux amd64, Go current']
  id: 'integration test, example from doc'
  entrypoint: 'bash'
  args:
  - -c
  - |
    cd "$(mktemp -d)";
    printf 'localhost:8000\n\nupload /web/path {\n  to "/var/tmp"\n  enable_webdav\n}\n' | tee Caddyfile;
    set -eux;
    /workspace/caddy.upload~amd64_linux & sleep 0.2;

    curl -sfS -T /etc/os-release http://localhost:8000/web/path/from-release && test -s /var/tmp/from-release;
    curl -sfS -F hostname=@/etc/hostname -F resolv.txt=@/etc/resolv.conf http://localhost:8000/web/path/;
    cmp -b /etc/hostname /var/tmp/hostname;
    cmp -b /etc/resolv.conf /var/tmp/resolv.conf;
    curl -sfS -X MOVE -H "Destination: /web/path/to-release" http://localhost:8000/web/path/from-release && test -s /var/tmp/to-release;
    curl -sfS -vX DELETE http://localhost:8000/web/path/to-release;

    curl -sfS -T /etc/os-release http://localhost:8000/web/path/subdir/os-release && test -s /var/tmp/subdir/os-release;
    rm -f /var/tmp/subdir/os-release;
    rmdir /var/tmp/subdir;

    kill %1

- name: 'gcr.io/cloud-builders/curl'
  waitFor: ['build linux amd64, Go current']
  id: 'integration test, image upload'
  entrypoint: 'bash'
  args:
  - -c
  - |
    cd "$(mktemp -d)";
    printf 'localhost:8000\n\nupload /web/path {\n  to "/var/tmp"\n  random_suffix_len 4\n}\n' | tee Caddyfile;
    set -eux;
    /workspace/caddy.upload~amd64_linux & sleep 0.2;

    truncate --size $[ 1*1024*1024 ] image1.jpg;
    curl -sfST image1.jpg http://localhost:8000/web/path/first-image.jpg;
    ls -1 /var/tmp/*.jpg;
    test -s /var/tmp/first-image_????.jpg;

    kill %1

# Do not uncomment this as Google Cloud Build for Github lacks the permissions to perform this step.
# Mark needs to issue the build separately, using a different account, for this to succeed.
#- name: 'docker.io/blitznote/debase:16.04'
#  waitFor: ['build linux amd64, Go current']
#  id: 'store dependencies'
#  volumes:
#  - name: 'third-party-sources'
#    path: '/var/go/theirs'
#  entrypoint: 'bash'
#  args:
#  - -c
#  - |
#    tar -C /var/go/theirs/ --sort=name \
#      --numeric-owner --owner=0 --group=0 \
#      --no-acls --no-selinux --no-xattrs \
#      --xz -cf "dependencies-$$(cat /var/go/theirs/src/${_CADDY_ORIGIN}/VERSION).tar.xz" \
#        $$(ls -1 /var/go/theirs)

#artifacts:
#  objects:
#    location: 'gs://cache_cloudbuild/caddy/'
#    paths: ['caddy.upload~*', 'dependencies-*']
